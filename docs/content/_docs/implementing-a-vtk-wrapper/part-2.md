---
layout: subpage
nav: docs
title: Part 2 - QML Type Registration
category: Implementing a VTK wrapper in QuickVtk
---
### Custom Types in QML
While [QML](https://doc.qt.io/qt-5/qtqml-index.html) provides a set of built-in types, custom types have to be registered and imported from a module first. Let's think about how we would like to access the wrapper from a [QML](https://doc.qt.io/qt-5/qtqml-index.html) perspective

>PointSource.qml
{: .hl-caption}

{% highlight qml %}
import Vtk 1.0 as Vtk

Vtk.PointSource {
  numberOfPoints: 1024;
}

{% endhighlight %}  

The [QML engine](https://doc.qt.io/qt-5/qqmlengine.html) resolves all types at runtime. In this case, [QML](https://doc.qt.io/qt-5/qtqml-index.html) is going to look for a [QObject](https://doc.qt.io/qt-5/qobject.html)-derived class named `PointSource` in a module called `Vtk`. If such a type exists, the C++ default constructor will be invoked and a new instance of this type is created.

## QML Type Registration
In order to access our custom type from [QML](https://doc.qt.io/qt-5/qtqml-index.html), we have to register it first. Behind the scenes, `qmlRegisterType<T>` is called for every custom [QML](https://doc.qt.io/qt-5/qtqml-index.html) type at application startup. QuickVtk provides a generic way of registering types via `Qml::Register::Symbol::Class<T>`

>quickVtkPointSource.hpp
{: .hl-caption}

{% highlight cpp %}
#pragma once

#include "quickVtkPolyDataAlgorithm.hpp"

namespace quick {
  namespace Vtk {

    class PointSource : public PolyDataAlgorithm {
    private:
      static Qml::Register::Symbol::Class<PointSource> Register;
    };
  }
}
{% endhighlight %}

`Class<T>` will register the type by extracting type information (class name and namespace) from the type's static [QMetaObject](https://doc.qt.io/qt-5/qmetaobject.html) property provided by the [QObject](https://doc.qt.io/qt-5/qobject.html) base. The [QML type registration article]({{ site.baseurl }}/docs/articles/qml-type-registration) provides a more in-depth explanation on [QML](https://doc.qt.io/qt-5/qtqml-index.html) type registration in QuickVtk.

Since `static` class members are not associated with objects of the class, they are independent variables with static storage duration and have to be defined explicitly on the **.cpp** side. Let's do this next

>quickVtkPointSource.cpp
{: .hl-caption}

{% highlight cpp %}
#include "quickVtkPointSource.hpp"

namespace quick {
  namespace Vtk {

    Qml::Register::Symbol::Class<PointSource> PointSource::Register(true);
  }
}

{% endhighlight %}

The `bool` argument indicates that this type wraps a class from the [VTK](https://vtk.org/) framework and is only used by the **API-Docs** target to determine whether an HTML link to the [VTK](https://vtk.org/) documentation should be provided or not. All [API Reference]({{ site.baseurl }}/api) pages are generated by processing types containing this static `Register` member variable.

# QML Type Registration
This article covers the generic type registration system in QuickVtk

## Type Registration in QML
C++ classes can be registered to the [QML](https://doc.qt.io/qt-5/qtqml-index.html) type system and be used in [QML](https://doc.qt.io/qt-5/qtqml-index.html) code if
- the type is derived from [QObject](https://doc.qt.io/qt-5/qobject.html)
- the class definition contains the `Q_OBJECT` macro

Custom C++ types have to be registered to [QML](https://doc.qt.io/qt-5/qtqml-index.html) explicitly. Usually this is done by calling `qmlRegisterType<T>` or other register methods provided by the [Qt](https://www.qt.io/) framework. Custom types must be registered on application startup before starting the application's [QML engine](https://doc.qt.io/qt-5/qqmlengine.html).



We now know that custom types have to be registered to a module before they can be accessed from [QML](https://doc.qt.io/qt-5/qtqml-index.html). Let's add the code for proper type registration to our class declaration.

>quickVtkPointSource.hpp
{: .hl-caption}

{% highlight cpp %}
#pragma once

namespace quick {

    namespace Vtk {

        class PointSource : public PolyDataAlgorithm {
        private:
          static Qml::Register::Symbol::Class<PointSource> Register;
        };
    }
}
{% endhighlight %}

The typename `Qml::Register::Symbol::Class<T>` already indicates that this line has something to do with [QML](https://doc.qt.io/qt-5/qtqml-index.html) type registration. We will take a look at how this works in just a second. But first we have to provide a *definition* on the **.cpp** side.

>quickVtkPointSource.cpp
{: .hl-caption}

{% highlight cpp %}
#include "quickVtkPointSource.hpp"

namespace quick {

    namespace Vtk {

        Qml::Register::Symbol::Class<PointSource> PointSource::Register(true);
    }
}

{% endhighlight %}

Note that `static` class members are not associated with objects of the class. They are independent variables with static storage duration and have to be defined explicitly.

## The generic type registration system
Usually, every [QML](https://doc.qt.io/qt-5/qtqml-index.html) application registeres a set of custom types on application startup by calling [qmlRegisterType\<T\>](https://doc.qt.io/qt-5/qqmlengine.html#qmlRegisterType-2) or other available register functions.

In our case we could write the following line in order to register our custom `PointSource` type to a module called `Vtk 1.0` in the [QML](https://doc.qt.io/qt-5/qtqml-index.html) context:

{% highlight cpp %}
qmlRegisterType<quick::Vtk::PointSource>("Vtk", 1, 0, "PointSource");
{% endhighlight %}

Instead of mapping each type individually like showcased in the above example, this can be done in a more generic fashion by creating an instance member of `Qml::Register::Symbol::Class<T>`. Let's take a look at a simplified version of `Class<T>` which can be found in `src/Lib/Utils/quickQmlRegister.hpp`

>quickQmlRegister.hpp
{: .hl-caption}

{% highlight cpp %}
// namespace quick::Vtk::Register::Symbol {

  template <class T>
  struct Class {

    Class(bool isWrapper = false) {
      QMetaObject metaObject = T::staticMetaObject;
      auto name = QString(metaObject.className());
      auto prefix = name.section("::", 1, 1);
      auto className = name.section("::", 2, 2);

      qmlRegisterType<T>(prefix.toStdString().c_str(), 1, 0, className.toStdString().c_str());

      Make::Class(metaObject, isWrapper);
    }
  };

{% endhighlight %}

Let's focus on the `qmlRegisterType<T>` function call. We know that the first parameter is used to identify the associated module which has to be imported in order to access a given type `T` from [QML](https://doc.qt.io/qt-5/qtqml-index.html). The second and third parameter specify the module version (1.0 in this case). Finally, the last argument identifies the typename of `T`.

As you can see, a static `QMetaObject` is acceessed through the generic type parameter `T` via `T::staticMetaObject`. In [Qt](https://www.qt.io/), all [QObject](https://doc.qt.io/qt-5/qobject.html)-derived classes provide such a static member which stores various type information. If you are new to [Qt](https://www.qt.io/), this pseudo-reflection system is one of the main framework features.

And that's basically it. `Class<T>` simply extracts the type prefix (the surrounding namespace which is `Vtk` for the `PointSource` class) as well as the typename and invokes a call to `qmlRegisterType<T>` with the correct arguments.

When taking a closer look at the actual implementation (`quickQmlRegister.hpp`), you'll see that it's a bit more complicated than that. In fact, the `Qml::Register` namespace provides many different ways of registering custom types in [QML](https://doc.qt.io/qt-5/qtqml-index.html) and also ensures that all types are registered at application startup. You can check out [this article]({{ site.baseurl }}/docs/articles/all-about-type-registration) for a more in-depth analysis of type registration in QuickVtk.

But for now let's sum up the most important things

- Custom types can be registered to [QML](https://doc.qt.io/qt-5/qtqml-index.html) by defining a static member variable using types from the `Qml::Register::Symbol` namespace
- Types can be registered as `Class`, `AbstractClass` and `UncreatableClass` since not all types exposed to [QML](https://doc.qt.io/qt-5/qtqml-index.html) are necessarily creatable. We will take a look at such types later.
- The optional `isWrapper` argument controls whether a custom type wraps a [VTK](https://vtk.org/) type or not. This is flag is used by the **API-Docs** target and determines if a certain type should provide a link to the [VTK](https://vtk.org/) documentation website.
- All registered types must derive from [QObject](https://doc.qt.io/qt-5/qobject.html) as we will see soon. This is ensured by `T::staticMetaObject` which is checked at compile-time (see [SFINAE](https://en.cppreference.com/w/cpp/language/sfinae)).
